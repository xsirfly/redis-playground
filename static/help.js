
var commandHelp = [
    {cmd: "APPEND", args: "key value", desc: "Append a value to a key"},
    {cmd: "AUTH", args: "password", desc: "Authenticate to the server"},
    {cmd: "BGREWRITEAOF", args: "-", desc: "Asynchronously rewrite the append-only file"},
    {cmd: "BGSAVE", args: "-", desc: "Asynchronously save the dataset to disk"},
    {cmd: "BITCOUNT", args: "key [start end]", desc: "Count set bits in a string"},
    {cmd: "BITFIELD", args: "key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]", desc: "Perform arbitrary bitfield integer operations on strings"},
    {cmd: "BITOP", args: "operation destkey key [key ...]", desc: "Perform bitwise operations between strings"},
    {cmd: "BITPOS", args: "key bit [start] [end]", desc: "Find first bit set or clear in a string"},
    {cmd: "BLPOP", args: "key [key ...] timeout", desc: "Remove and get the first element in a list, or block until one is available"},
    {cmd: "BRPOP", args: "key [key ...] timeout", desc: "Remove and get the last element in a list, or block until one is available"},
    {cmd: "BRPOPLPUSH", args: "source destination timeout", desc: "Pop a value from a list, push it to another list and return it; or block until one is available"},
    {cmd: "BZPOPMAX", args: "key [key ...] timeout", desc: "Remove and return the member with the highest score from one or more sorted sets, or block until one is available"},
    {cmd: "BZPOPMIN", args: "key [key ...] timeout", desc: "Remove and return the member with the lowest score from one or more sorted sets, or block until one is available"},
    {cmd: "CLIENT GETNAME", args: "-", desc: "Get the current connection name"},
    {cmd: "CLIENT KILL", args: "[ip:port] [ID client-id] [TYPE normal|master|slave|pubsub] [ADDR ip:port] [SKIPME yes/no]", desc: "Kill the connection of a client"},
    {cmd: "CLIENT LIST", args: "-", desc: "Get the list of client connections"},
    {cmd: "CLIENT PAUSE", args: "timeout", desc: "Stop processing commands from clients for some time"},
    {cmd: "CLIENT REPLY", args: "ON|OFF|SKIP", desc: "Instruct the server whether to reply to commands"},
    {cmd: "CLIENT SETNAME", args: "connection-name", desc: "Set the current connection name"},
    {cmd: "CLUSTER ADDSLOTS", args: "slot [slot ...]", desc: "Assign new hash slots to receiving node"},
    {cmd: "CLUSTER COUNT-FAILURE-REPORTS", args: "node-id", desc: "Return the number of failure reports active for a given node"},
    {cmd: "CLUSTER COUNTKEYSINSLOT", args: "slot", desc: "Return the number of local keys in the specified hash slot"},
    {cmd: "CLUSTER DELSLOTS", args: "slot [slot ...]", desc: "Set hash slots as unbound in receiving node"},
    {cmd: "CLUSTER FAILOVER", args: "[FORCE|TAKEOVER]", desc: "Forces a slave to perform a manual failover of its master."},
    {cmd: "CLUSTER FORGET", args: "node-id", desc: "Remove a node from the nodes table"},
    {cmd: "CLUSTER GETKEYSINSLOT", args: "slot count", desc: "Return local key names in the specified hash slot"},
    {cmd: "CLUSTER INFO", args: "-", desc: "Provides info about Redis Cluster node state"},
    {cmd: "CLUSTER KEYSLOT", args: "key", desc: "Returns the hash slot of the specified key"},
    {cmd: "CLUSTER MEET", args: "ip port", desc: "Force a node cluster to handshake with another node"},
    {cmd: "CLUSTER NODES", args: "-", desc: "Get Cluster config for the node"},
    {cmd: "CLUSTER REPLICATE", args: "node-id", desc: "Reconfigure a node as a slave of the specified master node"},
    {cmd: "CLUSTER RESET", args: "[HARD|SOFT]", desc: "Reset a Redis Cluster node"},
    {cmd: "CLUSTER SAVECONFIG", args: "-", desc: "Forces the node to save cluster state on disk"},
    {cmd: "CLUSTER SET-CONFIG-EPOCH", args: "config-epoch", desc: "Set the configuration epoch in a new node"},
    {cmd: "CLUSTER SETSLOT", args: "slot IMPORTING|MIGRATING|STABLE|NODE [node-id]", desc: "Bind a hash slot to a specific node"},
    {cmd: "CLUSTER SLAVES", args: "node-id", desc: "List slave nodes of the specified master node"},
    {cmd: "CLUSTER SLOTS", args: "-", desc: "Get array of Cluster slot to node mappings"},
    {cmd: "COMMAND", args: "-", desc: "Get array of Redis command details"},
    {cmd: "COMMAND COUNT", args: "-", desc: "Get total number of Redis commands"},
    {cmd: "COMMAND GETKEYS", args: "-", desc: "Extract keys given a full Redis command"},
    {cmd: "COMMAND INFO", args: "command-name [command-name ...]", desc: "Get array of specific Redis command details"},
    {cmd: "CONFIG GET", args: "parameter", desc: "Get the value of a configuration parameter"},
    {cmd: "CONFIG RESETSTAT", args: "-", desc: "Reset the stats returned by INFO"},
    {cmd: "CONFIG REWRITE", args: "-", desc: "Rewrite the configuration file with the in memory configuration"},
    {cmd: "CONFIG SET", args: "parameter value", desc: "Set a configuration parameter to the given value"},
    {cmd: "DBSIZE", args: "-", desc: "Return the number of keys in the selected database"},
    {cmd: "DEBUG OBJECT", args: "key", desc: "Get debugging information about a key"},
    {cmd: "DEBUG SEGFAULT", args: "-", desc: "Make the server crash"},
    {cmd: "DECR", args: "key", desc: "Decrement the integer value of a key by one"},
    {cmd: "DECRBY", args: "key decrement", desc: "Decrement the integer value of a key by the given number"},
    {cmd: "DEL", args: "key [key ...]", desc: "Delete a key"},
    {cmd: "DISCARD", args: "-", desc: "Discard all commands issued after MULTI"},
    {cmd: "DUMP", args: "key", desc: "Return a serialized version of the value stored at the specified key."},
    {cmd: "ECHO", args: "message", desc: "Echo the given string"},
    {cmd: "EVAL", args: "script numkeys key [key ...] arg [arg ...]", desc: "Execute a Lua script server side"},
    {cmd: "EVALSHA", args: "sha1 numkeys key [key ...] arg [arg ...]", desc: "Execute a Lua script server side"},
    {cmd: "EXEC", args: "-", desc: "Execute all commands issued after MULTI"},
    {cmd: "EXISTS", args: "key [key ...]", desc: "Determine if a key exists"},
    {cmd: "EXPIRE", args: "key seconds", desc: "Set a key's time to live in seconds"},
    {cmd: "EXPIREAT", args: "key timestamp", desc: "Set the expiration for a key as a UNIX timestamp"},
    {cmd: "FLUSHALL", args: "[ASYNC]", desc: "Remove all keys from all databases"},
    {cmd: "FLUSHDB", args: "[ASYNC]", desc: "Remove all keys from the current database"},
    {cmd: "GEOADD", args: "key longitude latitude member [longitude latitude member ...]", desc: "Add one or more geospatial items in the geospatial index represented using a sorted set"},
    {cmd: "GEODIST", args: "key member1 member2 [unit]", desc: "Returns the distance between two members of a geospatial index"},
    {cmd: "GEOHASH", args: "key member [member ...]", desc: "Returns members of a geospatial index as standard geohash strings"},
    {cmd: "GEOPOS", args: "key member [member ...]", desc: "Returns longitude and latitude of members of a geospatial index"},
    {cmd: "GEORADIUS", args: "key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]", desc: "Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a point"},
    {cmd: "GEORADIUSBYMEMBER", args: "key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]", desc: "Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a member"},
    {cmd: "GET", args: "key", desc: "Get the value of a key"},
    {cmd: "GETBIT", args: "key offset", desc: "Returns the bit value at offset in the string value stored at key"},
    {cmd: "GETRANGE", args: "key start end", desc: "Get a substring of the string stored at a key"},
    {cmd: "GETSET", args: "key value", desc: "Set the string value of a key and return its old value"},
    {cmd: "HDEL", args: "key field [field ...]", desc: "Delete one or more hash fields"},
    {cmd: "HEXISTS", args: "key field", desc: "Determine if a hash field exists"},
    {cmd: "HGET", args: "key field", desc: "Get the value of a hash field"},
    {cmd: "HGETALL", args: "key", desc: "Get all the fields and values in a hash"},
    {cmd: "HINCRBY", args: "key field increment", desc: "Increment the integer value of a hash field by the given number"},
    {cmd: "HINCRBYFLOAT", args: "key field increment", desc: "Increment the float value of a hash field by the given amount"},
    {cmd: "HKEYS", args: "key", desc: "Get all the fields in a hash"},
    {cmd: "HLEN", args: "key", desc: "Get the number of fields in a hash"},
    {cmd: "HMGET", args: "key field [field ...]", desc: "Get the values of all the given hash fields"},
    {cmd: "HMSET", args: "key field value [field value ...]", desc: "Set multiple hash fields to multiple values"},
    {cmd: "HSCAN", args: "key cursor [MATCH pattern] [COUNT count]", desc: "Incrementally iterate hash fields and associated values"},
    {cmd: "HSET", args: "key field value", desc: "Set the string value of a hash field"},
    {cmd: "HSETNX", args: "key field value", desc: "Set the value of a hash field, only if the field does not exist"},
    {cmd: "HSTRLEN", args: "key field", desc: "Get the length of the value of a hash field"},
    {cmd: "HVALS", args: "key", desc: "Get all the values in a hash"},
    {cmd: "INCR", args: "key", desc: "Increment the integer value of a key by one"},
    {cmd: "INCRBY", args: "key increment", desc: "Increment the integer value of a key by the given amount"},
    {cmd: "INCRBYFLOAT", args: "key increment", desc: "Increment the float value of a key by the given amount"},
    {cmd: "INFO", args: "[section]", desc: "Get information and statistics about the server"},
    {cmd: "KEYS", args: "pattern", desc: "Find all keys matching the given pattern"},
    {cmd: "LASTSAVE", args: "-", desc: "Get the UNIX time stamp of the last successful save to disk"},
    {cmd: "LINDEX", args: "key index", desc: "Get an element from a list by its index"},
    {cmd: "LINSERT", args: "key BEFORE|AFTER pivot value", desc: "Insert an element before or after another element in a list"},
    {cmd: "LLEN", args: "key", desc: "Get the length of a list"},
    {cmd: "LPOP", args: "key", desc: "Remove and get the first element in a list"},
    {cmd: "LPUSH", args: "key value [value ...]", desc: "Prepend one or multiple values to a list"},
    {cmd: "LPUSHX", args: "key value", desc: "Prepend a value to a list, only if the list exists"},
    {cmd: "LRANGE", args: "key start stop", desc: "Get a range of elements from a list"},
    {cmd: "LREM", args: "key count value", desc: "Remove elements from a list"},
    {cmd: "LSET", args: "key index value", desc: "Set the value of an element in a list by its index"},
    {cmd: "LTRIM", args: "key start stop", desc: "Trim a list to the specified range"},
    {cmd: "MEMORY DOCTOR", args: "-", desc: "Outputs memory problems report"},
    {cmd: "MEMORY HELP", args: "-", desc: "Show helpful text about the different subcommands"},
    {cmd: "MEMORY MALLOC-STATS", args: "-", desc: "Show allocator internal stats"},
    {cmd: "MEMORY PURGE", args: "-", desc: "Ask the allocator to release memory"},
    {cmd: "MEMORY STATS", args: "-", desc: "Show memory usage details"},
    {cmd: "MEMORY USAGE", args: "key [SAMPLES count]", desc: "Estimate the memory usage of a key"},
    {cmd: "MGET", args: "key [key ...]", desc: "Get the values of all the given keys"},
    {cmd: "MIGRATE", args: "host port key| destination-db timeout [COPY] [REPLACE] [KEYS key]", desc: "Atomically transfer a key from a Redis instance to another one."},
    {cmd: "MONITOR", args: "-", desc: "Listen for all requests received by the server in real time"},
    {cmd: "MOVE", args: "key db", desc: "Move a key to another database"},
    {cmd: "MSET", args: "key value [key value ...]", desc: "Set multiple keys to multiple values"},
    {cmd: "MSETNX", args: "key value [key value ...]", desc: "Set multiple keys to multiple values, only if none of the keys exist"},
    {cmd: "MULTI", args: "-", desc: "Mark the start of a transaction block"},
    {cmd: "OBJECT", args: "subcommand [arguments [arguments ...]]", desc: "Inspect the internals of Redis objects"},
    {cmd: "PERSIST", args: "key", desc: "Remove the expiration from a key"},
    {cmd: "PEXPIRE", args: "key milliseconds", desc: "Set a key's time to live in milliseconds"},
    {cmd: "PEXPIREAT", args: "key milliseconds-timestamp", desc: "Set the expiration for a key as a UNIX timestamp specified in milliseconds"},
    {cmd: "PFADD", args: "key element [element ...]", desc: "Adds the specified elements to the specified HyperLogLog."},
    {cmd: "PFCOUNT", args: "key [key ...]", desc: "Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s)."},
    {cmd: "PFMERGE", args: "destkey sourcekey [sourcekey ...]", desc: "Merge N different HyperLogLogs into a single one."},
    {cmd: "PING", args: "[message]", desc: "Ping the server"},
    {cmd: "PSETEX", args: "key milliseconds value", desc: "Set the value and expiration in milliseconds of a key"},
    {cmd: "PSUBSCRIBE", args: "pattern [pattern ...]", desc: "Listen for messages published to channels matching the given patterns"},
    {cmd: "PTTL", args: "key", desc: "Get the time to live for a key in milliseconds"},
    {cmd: "PUBLISH", args: "channel message", desc: "Post a message to a channel"},
    {cmd: "PUBSUB", args: "subcommand [argument [argument ...]]", desc: "Inspect the state of the Pub/Sub subsystem"},
    {cmd: "PUNSUBSCRIBE", args: "[pattern [pattern ...]]", desc: "Stop listening for messages posted to channels matching the given patterns"},
    {cmd: "QUIT", args: "-", desc: "Close the connection"},
    {cmd: "RANDOMKEY", args: "-", desc: "Return a random key from the keyspace"},
    {cmd: "READONLY", args: "-", desc: "Enables read queries for a connection to a cluster slave node"},
    {cmd: "READWRITE", args: "-", desc: "Disables read queries for a connection to a cluster slave node"},
    {cmd: "RENAME", args: "key newkey", desc: "Rename a key"},
    {cmd: "RENAMENX", args: "key newkey", desc: "Rename a key, only if the new key does not exist"},
    {cmd: "RESTORE", args: "key ttl serialized-value [REPLACE]", desc: "Create a key using the provided serialized value, previously obtained using DUMP."},
    {cmd: "ROLE", args: "-", desc: "Return the role of the instance in the context of replication"},
    {cmd: "RPOP", args: "key", desc: "Remove and get the last element in a list"},
    {cmd: "RPOPLPUSH", args: "source destination", desc: "Remove the last element in a list, prepend it to another list and return it"},
    {cmd: "RPUSH", args: "key value [value ...]", desc: "Append one or multiple values to a list"},
    {cmd: "RPUSHX", args: "key value", desc: "Append a value to a list, only if the list exists"},
    {cmd: "SADD", args: "key member [member ...]", desc: "Add one or more members to a set"},
    {cmd: "SAVE", args: "-", desc: "Synchronously save the dataset to disk"},
    {cmd: "SCAN", args: "cursor [MATCH pattern] [COUNT count]", desc: "Incrementally iterate the keys space"},
    {cmd: "SCARD", args: "key", desc: "Get the number of members in a set"},
    {cmd: "SCRIPT DEBUG", args: "YES|SYNC|NO", desc: "Set the debug mode for executed scripts."},
    {cmd: "SCRIPT EXISTS", args: "sha1 [sha1 ...]", desc: "Check existence of scripts in the script cache."},
    {cmd: "SCRIPT FLUSH", args: "-", desc: "Remove all the scripts from the script cache."},
    {cmd: "SCRIPT KILL", args: "-", desc: "Kill the script currently in execution."},
    {cmd: "SCRIPT LOAD", args: "script", desc: "Load the specified Lua script into the script cache."},
    {cmd: "SDIFF", args: "key [key ...]", desc: "Subtract multiple sets"},
    {cmd: "SDIFFSTORE", args: "destination key [key ...]", desc: "Subtract multiple sets and store the resulting set in a key"},
    {cmd: "SELECT", args: "index", desc: "Change the selected database for the current connection"},
    {cmd: "SET", args: "key value [expiration EX seconds|PX milliseconds] [NX|XX]", desc: "Set the string value of a key"},
    {cmd: "SETBIT", args: "key offset value", desc: "Sets or clears the bit at offset in the string value stored at key"},
    {cmd: "SETEX", args: "key seconds value", desc: "Set the value and expiration of a key"},
    {cmd: "SETNX", args: "key value", desc: "Set the value of a key, only if the key does not exist"},
    {cmd: "SETRANGE", args: "key offset value", desc: "Overwrite part of a string at key starting at the specified offset"},
    {cmd: "SHUTDOWN", args: "[NOSAVE|SAVE]", desc: "Synchronously save the dataset to disk and then shut down the server"},
    {cmd: "SINTER", args: "key [key ...]", desc: "Intersect multiple sets"},
    {cmd: "SINTERSTORE", args: "destination key [key ...]", desc: "Intersect multiple sets and store the resulting set in a key"},
    {cmd: "SISMEMBER", args: "key member", desc: "Determine if a given value is a member of a set"},
    {cmd: "SLAVEOF", args: "host port", desc: "Make the server a slave of another instance, or promote it as master"},
    {cmd: "SLOWLOG", args: "subcommand [argument]", desc: "Manages the Redis slow queries log"},
    {cmd: "SMEMBERS", args: "key", desc: "Get all the members in a set"},
    {cmd: "SMOVE", args: "source destination member", desc: "Move a member from one set to another"},
    {cmd: "SORT", args: "key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]", desc: "Sort the elements in a list, set or sorted set"},
    {cmd: "SPOP", args: "key [count]", desc: "Remove and return one or multiple random members from a set"},
    {cmd: "SRANDMEMBER", args: "key [count]", desc: "Get one or multiple random members from a set"},
    {cmd: "SREM", args: "key member [member ...]", desc: "Remove one or more members from a set"},
    {cmd: "SSCAN", args: "key cursor [MATCH pattern] [COUNT count]", desc: "Incrementally iterate Set elements"},
    {cmd: "STRLEN", args: "key", desc: "Get the length of the value stored in a key"},
    {cmd: "SUBSCRIBE", args: "channel [channel ...]", desc: "Listen for messages published to the given channels"},
    {cmd: "SUNION", args: "key [key ...]", desc: "Add multiple sets"},
    {cmd: "SUNIONSTORE", args: "destination key [key ...]", desc: "Add multiple sets and store the resulting set in a key"},
    {cmd: "SWAPDB", args: "index index", desc: "Swaps two Redis databases"},
    {cmd: "SYNC", args: "-", desc: "Internal command used for replication"},
    {cmd: "TIME", args: "-", desc: "Return the current server time"},
    {cmd: "TOUCH", args: "key [key ...]", desc: "Alters the last access time of a key(s). Returns the number of existing keys specified."},
    {cmd: "TTL", args: "key", desc: "Get the time to live for a key"},
    {cmd: "TYPE", args: "key", desc: "Determine the type stored at key"},
    {cmd: "UNLINK", args: "key [key ...]", desc: "Delete a key asynchronously in another thread. Otherwise it is just as DEL, but non blocking."},
    {cmd: "UNSUBSCRIBE", args: "[channel [channel ...]]", desc: "Stop listening for messages posted to the given channels"},
    {cmd: "UNWATCH", args: "-", desc: "Forget about all watched keys"},
    {cmd: "WAIT", args: "numslaves timeout", desc: "Wait for the synchronous replication of all the write commands sent in the context of the current connection"},
    {cmd: "WATCH", args: "key [key ...]", desc: "Watch the given keys to determine execution of the MULTI/EXEC block"},
    {cmd: "XADD", args: "key ID field string [field string ...]", desc: "Appends a new entry to a stream"},
    {cmd: "XLEN", args: "key", desc: "Return the number of entires in a stream"},
    {cmd: "XPENDING", args: "key group [start end count] [consumer]", desc: "Return information and entries from a stream conusmer group pending entries list, that are messages fetched but never acknowledged."},
    {cmd: "XRANGE", args: "key start end [COUNT count]", desc: "Return a range of elements in a stream, with IDs matching the specified IDs interval"},
    {cmd: "XREAD", args: "[COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]", desc: "Return never seen elements in multiple streams, with IDs greater than the ones reported by the caller for each stream. Can block."},
    {cmd: "XREADGROUP", args: "GROUP group consumer [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]", desc: "Return new entries from a stream using a consumer group, or access the history of the pending entries for a given consumer. Can block."},
    {cmd: "XREVRANGE", args: "key end start [COUNT count]", desc: "Return a range of elements in a stream, with IDs matching the specified IDs interval, in reverse order (from greater to smaller IDs) compared to XRANGE"},
    {cmd: "ZADD", args: "key [NX|XX] [CH] [INCR] score member [score member ...]", desc: "Add one or more members to a sorted set, or update its score if it already exists"},
    {cmd: "ZCARD", args: "key", desc: "Get the number of members in a sorted set"},
    {cmd: "ZCOUNT", args: "key min max", desc: "Count the members in a sorted set with scores within the given values"},
    {cmd: "ZINCRBY", args: "key increment member", desc: "Increment the score of a member in a sorted set"},
    {cmd: "ZINTERSTORE", args: "destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]", desc: "Intersect multiple sorted sets and store the resulting sorted set in a new key"},
    {cmd: "ZLEXCOUNT", args: "key min max", desc: "Count the number of members in a sorted set between a given lexicographical range"},
    {cmd: "ZPOPMAX", args: "key [count]", desc: "Remove and return members with the highest scores in a sorted set"},
    {cmd: "ZPOPMIN", args: "key [count]", desc: "Remove and return members with the lowest scores in a sorted set"},
    {cmd: "ZRANGE", args: "key start stop [WITHSCORES]", desc: "Return a range of members in a sorted set, by index"},
    {cmd: "ZRANGEBYLEX", args: "key min max [LIMIT offset count]", desc: "Return a range of members in a sorted set, by lexicographical range"},
    {cmd: "ZRANGEBYSCORE", args: "key min max [WITHSCORES] [LIMIT offset count]", desc: "Return a range of members in a sorted set, by score"},
    {cmd: "ZRANK", args: "key member", desc: "Determine the index of a member in a sorted set"},
    {cmd: "ZREM", args: "key member [member ...]", desc: "Remove one or more members from a sorted set"},
    {cmd: "ZREMRANGEBYLEX", args: "key min max", desc: "Remove all members in a sorted set between the given lexicographical range"},
    {cmd: "ZREMRANGEBYRANK", args: "key start stop", desc: "Remove all members in a sorted set within the given indexes"},
    {cmd: "ZREMRANGEBYSCORE", args: "key min max", desc: "Remove all members in a sorted set within the given scores"},
    {cmd: "ZREVRANGE", args: "key start stop [WITHSCORES]", desc: "Return a range of members in a sorted set, by index, with scores ordered from high to low"},
    {cmd: "ZREVRANGEBYLEX", args: "key max min [LIMIT offset count]", desc: "Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings."},
    {cmd: "ZREVRANGEBYSCORE", args: "key max min [WITHSCORES] [LIMIT offset count]", desc: "Return a range of members in a sorted set, by score, with scores ordered from high to low"},
    {cmd: "ZREVRANK", args: "key member", desc: "Determine the index of a member in a sorted set, with scores ordered from high to low"},
    {cmd: "ZSCAN", args: "key cursor [MATCH pattern] [COUNT count]", desc: "Incrementally iterate sorted sets elements and associated scores"},
    {cmd: "ZSCORE", args: "key member", desc: "Get the score associated with the given member in a sorted set"},
    {cmd: "ZUNIONSTORE", args: "destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]", desc: "Add multiple sorted sets and store the resulting sorted set in a new key"},
];

function getHelp(command) {
    command = command.toLocaleUpperCase();
    for(var i = 0; i < commandHelp.length; i++) {
        if(command == commandHelp[i]["cmd"]) {
            return commandHelp[i];
        }
    }
    return null;
}